---
title: "VirPipe summary report: `r params$prefix` "
output: html_document
params:
  version: "v1.0"
  prefix: ""
  outdir: ""
  qc_link: ""
  map_summary_file: ""
  tax_classify_directory: ""
  tax_classify_kraken_link: ""
  assembly_directory: ""
  blast_blastn_file: ""
  blastn_html_link: ""
  blast_megablast_file: ""
  megablast_html_link: ""
  zoonotic_rank_predictions_file: ""
---

```{r include=FALSE}
knitr::opts_chunk$set(echo=FALSE)
```

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(data.table)
library(DT)
library(ggplot2)
library(kableExtra)
```

```{r}
# --- Parsing functions ---
map_to_table <- function(text_file) {
  ret <- read.table(text_file, header = TRUE, sep = "", strip.white = TRUE)
  ret <- select(ret, -c("N_COVERED_BASES", "AVG_BASEQ", "AVG_MAPQ"))
  return(ret)
}

blast_to_table <- function(text_file) {
  ret <- read.table(text_file, header = TRUE, sep = "\t", strip.white = TRUE, quote="", fill = TRUE)
  ret$BITSCORE <- as.integer(ret$BITSCORE)
  ret$TAX_ID <- as.factor(ret$TAX_ID)
  return(ret)
}

uniq_taxid <- function(blast_table) {
  ret <- blast_table[order(-blast_table$"BITSCORE"),]
  ret$TAX_ID <- as.character(ret$TAX_ID)
  ret <- ret[!duplicated(ret[ , "TAX_ID"]), ]
  cnt <- as.data.frame(table(blast_table$"TAX_ID"))
  colnames(cnt) <- c("TAX_ID", "NUM_CONTIGS")

  ret <- inner_join(ret, cnt, by = "TAX_ID")
  ret <- ret[c("NUM_CONTIGS", "TAX_ID", "BITSCORE")]
  ret <- ret[order(-ret$"BITSCORE"),]
  ret$TAX_ID <- as.factor(ret$TAX_ID)
  colnames(ret) <- c("NUM_CONTIGS", "TAX_ID", "BEST_BITSCORE")
  return(ret)
}

zoonotic_rank_to_table <- function(text_file) {
  ret <- read.csv(text_file)
  ret <- ret[c("Name", "priority_category")]
  colnames(ret) <- c("NAME", "ZOONOTIC POTENTIAL")
  level.order <- c("Very high", "High", "Medium", "Low")
  ret$"ZOONOTIC POTENTIAL" <- factor(ret$"ZOONOTIC POTENTIAL", levels= level.order)
  ret <- ret[ret$"ZOONOTIC POTENTIAL" %in% c("Very high", "High"),]
  ret <- ret[order(ret$"ZOONOTIC POTENTIAL", nchar(ret$NAME), ret$NAME),]
  rownames(ret) <- NULL
  return(ret)
}

# --- Input Data ---
prefix <- params$prefix

```

A summary report that displays the results generated from VirPipe `r params$version`.

This report contains the analysis result of the run named **`r prefix`**.

```{r qc_link}
qc_link_exists <- file.exists(params$qc_link)
if (qc_link_exists) {
  normalized_qc_link <- params$qc_link
}
```

```{r, results='asis', eval = qc_link_exists, echo=FALSE}

cat('# QC\n')

cat('QC result of the given input fastq file(s). The report is linked [here](', normalized_qc_link, ').\n')
```

```{r map_summary}
map_summary_exists <- file.exists(params$map_summary_file)
```
```{r, results='asis', eval = map_summary_exists, echo=FALSE}
cat('# Reference mapping\n')
```

```{r, eval=map_summary_exists}
map_summary_table <- map_to_table(params$map_summary_file)

map_summary_table %>%
  kbl(align = "ccc") %>%
  kable_styling()
```

```{r tax_classify_directory}
tax_classify_directory_exists <- dir.exists(params$tax_classify_directory)
```
```{r, results='asis', eval = tax_classify_directory_exists, echo=FALSE}
cat('\n# Taxonomic classification\n')
```

```{r tax_classify_heatmaps}
tax_classify_family_exists <- file.exists(paste(params$tax_classify_directory, prefix, "_family.svg", sep=""))
tax_classify_genus_exists <- file.exists(paste(params$tax_classify_directory, prefix, "_genus.svg", sep=""))
tax_classify_species_exists <- file.exists(paste(params$tax_classify_directory, prefix, "_species.svg", sep=""))
heatmap_exists <- tax_classify_family_exists | tax_classify_genus_exists | tax_classify_species_exists
if (tax_classify_family_exists) {
  normalized_tax_classify_family_heatmap_link <- normalizePath(paste(params$tax_classify_directory, prefix, "_family.svg", sep=""))
}
if (tax_classify_genus_exists) {
  normalized_tax_classify_genus_heatmap_link <- normalizePath(paste(params$tax_classify_directory, prefix, "_genus.svg", sep=""))
}
if (tax_classify_species_exists) {
  normalized_tax_classify_species_heatmap_link <- normalizePath(paste(params$tax_classify_directory, prefix, "_species.svg", sep=""))
}
```

```{r, results='asis', eval = heatmap_exists, echo=FALSE}
cat('## Taxonomy heatmaps\n\n')
```

```{r, results='asis', eval = tax_classify_family_exists, echo=FALSE}
cat('#### Family\n')
cat('![](', normalized_tax_classify_family_heatmap_link, ')')
```

```{r, results='asis', eval = tax_classify_genus_exists, echo=FALSE}
cat('#### Genus\n')
cat('![](', normalized_tax_classify_genus_heatmap_link, ')')
```

```{r, results='asis', eval = tax_classify_species_exists, echo=FALSE}
cat('#### Species\n')
cat('![](', normalized_tax_classify_species_heatmap_link, ')')
```


```{r tax_classify_kraken_link}
tax_classify_kraken_exists <- file.exists(params$tax_classify_kraken_link)
if (tax_classify_kraken_exists) {
  normalized_tax_classify_kraken_link <- params$tax_classify_kraken_link
}
```
```{r, results='asis', eval = tax_classify_kraken_exists, echo=FALSE}
cat('## Krona chart\n\n')
cat('The piechart generated with Krona from Kraken result is linked [here](', normalized_tax_classify_kraken_link, ').\n')
```

```{r assembly_directory}
assembly_directory_exists <- dir.exists(params$assembly_directory)
```
```{r, results='asis', eval = assembly_directory_exists, echo=FALSE}
cat('\n# De novo assembly\n')
```

```{r blast_result}
blastn_exists <- file.exists(params$blast_blastn_file)
megablast_exists <- file.exists(params$blast_megablast_file)
blast_exists <- blastn_exists | megablast_exists
if (blastn_exists) {
  blast_blastn_table <- blast_to_table(params$blast_blastn_file)
  blast_uniq_blastn_table <- uniq_taxid(blast_blastn_table)
  blast_blastn_file <- params$blast_blastn_file
}
if (megablast_exists) {
  blast_megablast_table <- blast_to_table(params$blast_megablast_file)
  blast_uniq_megablast_table <- uniq_taxid(blast_megablast_table)
  blast_megablast_file <- params$blast_megablast_file
}
```

```{r blast_html_link}
blastn_html_exists <- file.exists(params$blastn_html_link)
megablast_html_exists <- file.exists(params$megablast_html_link)
if (blastn_html_exists) {
  normalized_blastn_html_link <- params$blastn_html_link
}
if (megablast_html_exists) {
  normalized_megablast_html_link <- params$megablast_html_link
}
```

```{r, results='asis', eval = blast_exists, echo=FALSE}
cat('## BLAST\n')
```
```{r, results='asis', eval = blastn_exists, echo=FALSE}
cat('#### BLASTn\n')
```
```{r, eval=blastn_exists}
blast_uniq_blastn_table %>%
  kbl(align = "ccc") %>%
  kable_styling()
```
```{r, results='asis', eval = blastn_exists, echo=FALSE}
cat('Full table is linked [here](', blast_blastn_file, ').')
```
```{r, results='asis', eval = blastn_html_exists, echo=FALSE}
cat('Functional table is linked [here](', normalized_blastn_html_link, ').')
```

```{r, results='asis', eval = megablast_exists}
cat('#### megaBLAST\n')
```
```{r, eval=megablast_exists}
blast_uniq_megablast_table %>%
  kbl(align = "ccc") %>%
  kable_styling()
```

```{r, results='asis', eval = megablast_exists, echo=FALSE}
cat('Full table is linked [here](', blast_megablast_file, ').\n')
```
```{r, results='asis', eval = megablast_html_exists, echo=FALSE}
cat('Functional table is linked [here](', normalized_blastn_html_link, ').\n')
```

```{r zoonotic_rank_link}
zoonotic_rank_exists <- file.exists(params$zoonotic_rank_predictions_file)
if (zoonotic_rank_exists) {
  normalized_zoonotic_rank_prediction_link <- params$zoonotic_rank_predictions_file
}
```
```{r, results='asis', eval = zoonotic_rank_exists}
cat('## Zoonotic Rank\n')
```

```{r, eval=zoonotic_rank_exists}
zoonotic_rank_predictions <- zoonotic_rank_to_table(params$zoonotic_rank_predictions_file)

zoonotic_rank_predictions %>%
  kbl(align = "ccc") %>%
  kable_paper() %>%
  scroll_box(width = "100%", height = "500px")
```
```{r, results='asis', eval=zoonotic_rank_exists, echo=FALSE}
cat('Sequences only with labels "Very high" and "High" are shown. All the data is linked [here](', normalized_zoonotic_rank_prediction_link, ').\n')
```

# Contact information
[The pipeline](https://github.com/KijinKims/Long-read-Seq-Virome-Pipeline) and this report generating module were developed by Kijin Kim.

If you encounter bugs or difficulties, please send me feedback by [e-mail](mailto:skkujin@gmail.com).
